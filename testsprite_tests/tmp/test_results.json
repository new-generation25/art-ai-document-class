[
  {
    "projectId": "53507cae-f23b-4e77-867b-e674622353b3",
    "testId": "26e0d954-d983-4ba3-a01c-7842a5a82029",
    "userId": "24684438-70f1-70c6-8d9f-d3fa20b9e4b9",
    "title": "TC001-Navigation Bar Sticky and Link Functionality",
    "description": "Verify that the navigation bar remains fixed at the top of the viewport during scrolling and all navigation links route correctly to their sections.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Scroll down the page to check if the navigation bar remains sticky and visible.\n        await page.mouse.wheel(0, 600)\n        \n\n        # -> Click each navigation link in the navigation bar to verify correct routing to their sections.\n        frame = context.pages[-1]\n        # Click the 'ì»¤ë¦¬í˜ëŸ¼' navigation link to verify routing.\n        elem = frame.locator('xpath=html/body/nav/div/div[2]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click the 'AI ë²ˆì—­ ì²´í—˜' navigation link to verify correct routing to its section.\n        frame = context.pages[-1]\n        # Click the 'AI ë²ˆì—­ ì²´í—˜' navigation link to verify routing.\n        elem = frame.locator('xpath=html/body/nav/div/div[2]/a[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click the 'ì‹¬ì‚¬ ì „ëµ' navigation link to verify correct routing to its section.\n        frame = context.pages[-1]\n        # Click the 'ì‹¬ì‚¬ ì „ëµ' navigation link to verify routing.\n        elem = frame.locator('xpath=html/body/nav/div/div[2]/a[3]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click the 'ì‹ ì²­í•˜ê¸°' button to verify correct routing or scrolling to the application section.\n        frame = context.pages[-1]\n        # Click the 'ì‹ ì²­í•˜ê¸°' button to verify routing.\n        elem = frame.locator('xpath=html/body/nav/div/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        await expect(frame.locator('text=ì»¤ë¦¬í˜ëŸ¼').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=AI ë²ˆì—­ ì²´í—˜').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=ì‹¬ì‚¬ ì „ëµ').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=ì‹ ì²­í•˜ê¸°').first).to_be_visible(timeout=30000)\n        # Check that the navigation bar is visible and fixed at the top on initial load\n        await expect(frame.locator('text=ğŸ¨').first).to_be_visible(timeout=30000)\n        # Scroll down the page and confirm the navigation bar remains sticky and visible\n        await page.mouse.wheel(0, 600)\n        await expect(frame.locator('text=ğŸ¨').first).to_be_visible(timeout=30000)\n        # Click each navigation link and validate navigation to corresponding sections\n        await frame.locator('text=ì»¤ë¦¬í˜ëŸ¼').first.click()\n        await expect(frame.locator('text=4ì£¼ ì§‘ì¤‘ ì»¤ë¦¬í˜ëŸ¼').first).to_be_visible(timeout=30000)\n        await frame.locator('text=AI ë²ˆì—­ ì²´í—˜').first.click()\n        await expect(frame.locator('text=ì••ë„ì  ë§¥ë½ íŒŒì•…').first).to_be_visible(timeout=30000)\n        await frame.locator('text=ì‹¬ì‚¬ ì „ëµ').first.click()\n        await expect(frame.locator('text=ì‹¬ì‚¬ìœ„ì›ì˜').first).to_be_visible(timeout=30000)\n        await frame.locator('text=ì‹ ì²­í•˜ê¸°').first.click()\n        await expect(frame.locator('text=AI í™œìš© ì›Œí¬ìˆ ì‹ ì²­ì„œ').first).to_be_visible(timeout=30000)\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/24684438-70f1-70c6-8d9f-d3fa20b9e4b9/1767157054633476//tmp/test_task/result.webm",
    "created": "2025-12-31T04:51:01.520Z",
    "modified": "2025-12-31T04:57:34.784Z"
  },
  {
    "projectId": "53507cae-f23b-4e77-867b-e674622353b3",
    "testId": "22f95382-0803-4679-9c99-842703f6c5a2",
    "userId": "24684438-70f1-70c6-8d9f-d3fa20b9e4b9",
    "title": "TC002-Weekly Curriculum Tab Buttons Functionality",
    "description": "Ensure that each weekly tab button toggles the display of detailed curriculum content correctly and visually distinguishes the selected tab.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Click on the 1ì£¼ì°¨ tab button to check if its detailed curriculum content is displayed and visually highlighted.\n        frame = context.pages[-1]\n        # Click on the 1ì£¼ì°¨ tab button\n        elem = frame.locator('xpath=html/body/section[2]/div[2]/div[3]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click on the 2ì£¼ì°¨ tab button to verify its detailed curriculum content display and visual highlight.\n        frame = context.pages[-1]\n        # Click on the 2ì£¼ì°¨ tab button\n        elem = frame.locator('xpath=html/body/section[2]/div[2]/div[3]/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click on the 3ì£¼ì°¨ tab button to verify its detailed curriculum content display and visual highlight.\n        frame = context.pages[-1]\n        # Click on the 3ì£¼ì°¨ tab button\n        elem = frame.locator('xpath=html/body/section[2]/div[2]/div[3]/button[3]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click on the 4ì£¼ì°¨ tab button to verify its detailed curriculum content display and visual highlight.\n        frame = context.pages[-1]\n        # Click on the 4ì£¼ì°¨ tab button\n        elem = frame.locator('xpath=html/body/section[2]/div[2]/div[3]/button[4]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        await expect(frame.locator('text=1ì£¼ì°¨').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=ì˜¤ë¦¬ì—”í…Œì´ì…˜').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=2ì£¼ì°¨').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=ë…¼ë¦¬ êµ¬ì¡°').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=3ì£¼ì°¨').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=ìƒì„¸ ê¸°íš').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=4ì£¼ì°¨').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=ìµœì¢… ì ê²€ (ì‹¬ì‚¬ìœ„ì›ì˜ ëˆˆ)').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=ì‹¬ì‚¬ìœ„ì› í˜ë¥´ì†Œë‚˜ë¥¼ í™œìš©í•œ ë¹„íŒì  ê²€í†  ë° ìµœì¢… ë³´ì™„').first).to_be_visible(timeout=30000)\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/24684438-70f1-70c6-8d9f-d3fa20b9e4b9/1767156838579802//tmp/test_task/result.webm",
    "created": "2025-12-31T04:51:01.576Z",
    "modified": "2025-12-31T04:53:58.732Z"
  },
  {
    "projectId": "53507cae-f23b-4e77-867b-e674622353b3",
    "testId": "e4877eea-a4bc-43cc-9fc2-ab95ff7218f2",
    "userId": "24684438-70f1-70c6-8d9f-d3fa20b9e4b9",
    "title": "TC003-Interactive Translation Demo Accuracy and Simulation",
    "description": "Validate the simulated AI translation that converts artist's abstract language inputs into administrative review-oriented language accurately, reflecting expected transformations.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Click on 'AI ë²ˆì—­ ì²´í—˜' link to navigate to the interactive translation demo section.\n        frame = context.pages[-1]\n        # Click on 'AI ë²ˆì—­ ì²´í—˜' link to go to the AI translation demo section\n        elem = frame.locator('xpath=html/body/nav/div/div[2]/a[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Select a sample artist language text from the dropdown and click the translate (lightning) button to trigger translation.\n        frame = context.pages[-1]\n        # Open the artist language dropdown to select a sample text\n        elem = frame.locator('xpath=html/body/section[3]/div[3]/div[2]/div/div/select').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click the translate (lightning) button to trigger the translation and verify the output in the admin logic text area.\n        frame = context.pages[-1]\n        # Click the translate (lightning) button to trigger the translation\n        elem = frame.locator('xpath=html/body/section[3]/div[3]/div[2]/div/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Select an empty or non-meaningful option from the dropdown if available, or try to clear selection and trigger translation to test graceful handling.\n        frame = context.pages[-1]\n        # Open the artist input dropdown to check for empty or non-meaningful options\n        elem = frame.locator('xpath=html/body/section[3]/div[3]/div[2]/div/div/select').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        frame = context.pages[-1]\n        # Click the translate button to trigger translation with current selection or empty input\n        elem = frame.locator('xpath=html/body/section[3]/div[3]/div[2]/div/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Try to select a non-meaningful or empty option if available in the dropdown or simulate empty input scenario and trigger translation to verify graceful handling.\n        frame = context.pages[-1]\n        # Open the artist input dropdown to check for any empty or non-meaningful options\n        elem = frame.locator('xpath=html/body/section[3]/div[3]/div[2]/div/div/select').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        frame = context.pages[-1]\n        # Click the translate button to trigger translation with current or empty selection\n        elem = frame.locator('xpath=html/body/section[3]/div[3]/div[2]/div/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        await expect(frame.locator('text=ê³ ë ¹í™” ì§€ì—­ì˜ \\'ìƒì• ì‚¬ ê¸°ë¡\\'ì„ í†µí•œ ì„¸ëŒ€ ê°„ ë¬¸í™” ê³µê°ëŒ€ í˜•ì„± í”„ë¡œì íŠ¸ [ë²ˆì—­ ì™„ë£Œ]').first).to_be_visible(timeout=30000)\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/24684438-70f1-70c6-8d9f-d3fa20b9e4b9/1767157030540372//tmp/test_task/result.webm",
    "created": "2025-12-31T04:51:01.610Z",
    "modified": "2025-12-31T04:57:10.717Z"
  },
  {
    "projectId": "53507cae-f23b-4e77-867b-e674622353b3",
    "testId": "03ee129c-30f9-44a1-9a5b-2cdbdfaa1a49",
    "userId": "24684438-70f1-70c6-8d9f-d3fa20b9e4b9",
    "title": "TC004-Workshop Application Modal Form Input Validation and Submission",
    "description": "Test the modal form that collects user personal information, AI experience, and expectations for correct input validations and successful submission handling.",
    "testStatus": "FAILED",
    "testError": "Test execution timed out after 15 minutes",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "",
    "created": "2025-12-31T04:51:01.619Z",
    "modified": "2025-12-31T04:51:01.619Z"
  },
  {
    "projectId": "53507cae-f23b-4e77-867b-e674622353b3",
    "testId": "ab811f94-6f6f-437b-abe9-404f400c4c50",
    "userId": "24684438-70f1-70c6-8d9f-d3fa20b9e4b9",
    "title": "TC005-Chart.js Evaluation Criteria Data Visualization Accuracy and Responsiveness",
    "description": "Verify that the Chart.js rendered chart accurately displays evaluation data, updates correctly if data changes, and responds well to different screen sizes.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Scroll down to locate the evaluation criteria chart section and confirm the chart is rendered correctly with data points matching the predefined criteria.\n        await page.mouse.wheel(0, 600)\n        \n\n        # -> Try interacting with the page elements that might trigger or reveal the evaluation criteria chart, such as buttons or tabs related to 'ì‹¬ì‚¬' (evaluation) or 'ì‹¬ì‚¬ ì „ëµ' (evaluation strategy).\n        frame = context.pages[-1]\n        # Click on the 'ì‹¬ì‚¬ ì „ëµ' link to try to reveal the evaluation criteria chart section\n        elem = frame.locator('xpath=html/body/nav/div/div[2]/a[3]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Resize the browser window to a smaller width to simulate a mobile viewport and verify the chart layout and labels adjust properly and remain fully visible and legible.\n        await page.goto('http://localhost:3000/#analytics', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        frame = context.pages[-1]\n        # Click on the 'ì‹¬ì‚¬ ì „ëµ' tab to show the evaluation criteria chart again.\n        elem = frame.locator('xpath=html/body/nav/div/div[2]/a[3]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        await page.mouse.wheel(0, 300)\n        \n\n        # -> Manually resize the browser window to smaller widths simulating mobile devices and visually confirm the chart layout and labels adjust properly and remain fully visible and legible. Then attempt to simulate a data update in the chart and verify dynamic update behavior.\n        await page.mouse.wheel(0, -300)\n        \n\n        await page.mouse.wheel(0, 300)\n        \n\n        # -> Attempt to simulate a data update in the chart programmatically or by interacting with any available UI elements that might trigger a chart data refresh, then verify the chart updates dynamically without visual errors.\n        frame = context.pages[-1]\n        # Click the button âš¡ to trigger any possible chart data update or refresh.\n        elem = frame.locator('xpath=html/body/section[3]/div[3]/div[2]/div/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        await expect(frame.locator('text=ì‹¬ì‚¬ ì „ëµ').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=ì••ë„ì  ë§¥ë½ íŒŒì•…').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=ì‹¤ì‹œê°„ ì •ë³´ ê²€ìƒ‰').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=ì˜ˆìˆ ê°€í˜• í–‰ì • ì–¸ì–´').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=4ì£¼ ì§‘ì¤‘ ì»¤ë¦¬í˜ëŸ¼').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=ì†Œìˆ˜ ì¸ì› 6ëª… ëª¨ì§‘').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=2026. 1. 7. ~ 1. 28. (ë§¤ì£¼ ìˆ˜) Â |Â  â° 10:00 ~ 12:00').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=íšŒí˜„ë™ ì†Œê·¹ì¥').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=AIë¼ëŠ” 'ë˜‘ë˜‘í•œ ë¹„ì„œ'ì™€ ì¹œí•´ì§€ê¸°').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=ë‚˜ì˜ ì˜ˆìˆ  ì² í•™ì„ ë‹´ì€ 'í•œ ì¤„ ìŠ¬ë¡œê±´' ì™„ì„±').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=AI ë§‰ë‚´ ë¹„ì„œ ì„ëª… ë° ì›ë¦¬ ì´í•´ (í• ë£¨ì‹œë„¤ì´ì…˜)').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=ì œë¯¸ë‚˜ì´ 3.0 Proì˜ íŠ¹ì§•: ê¸´ ë¬¸ë§¥ê³¼ ì‹¤ì‹œê°„ ê²€ìƒ‰').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=[ì‹¤ìŠµ] ë‚´ ì˜ˆìˆ ì  ì •ì²´ì„± ì •ì˜ ë° í‚¤ì›Œë“œ ë¶„ì„').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=ì•„ì´ë””ì–´ë¥¼ ì‚¬ì—… í…Œë§ˆë¡œ ë²ˆì—­í•˜ëŠ” ëŒ€í™”ë²•').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=AI ì˜ˆìˆ ê°€ ì–¸ì–´ ë²ˆì—­ê¸°').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=ê³ ë ¹í™” ì§€ì—­ì˜ 'ìƒì• ì‚¬ ê¸°ë¡'ì„ í†µí•œ ì„¸ëŒ€ ê°„ ë¬¸í™” ê³µê°ëŒ€ í˜•ì„± í”„ë¡œì íŠ¸ [ë²ˆì—­ ì™„ë£Œ]').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=ì‹¬ì‚¬ìœ„ì›ì˜').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=ë§ˆìŒì„ ì—¬ëŠ” ì „ëµ').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=ìš°ìˆ˜í•œ ì˜ˆìˆ ì„±(30%)ë„ ì¤‘ìš”í•˜ì§€ë§Œ, í•©ê²©ì˜ ë‹¹ë½ì€ ì‹¤í˜„ê°€ëŠ¥ì„±(30%)ê³¼ ì‚¬ì—…ìˆ˜í–‰ì—­ëŸ‰(20%)ì—ì„œ ê²°ì •ë©ë‹ˆë‹¤. ì›Œí¬ìˆì—ì„œëŠ” AIë¥¼ í™œìš©í•´ ì´ 50%ë¥¼ ì™„ë²½í•˜ê²Œ í™•ë³´í•©ë‹ˆë‹¤.').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=ë°ì´í„° ê¸°ë°˜ì˜ êµ¬ì²´ì ì¸ ì‚¬ì—… í•„ìš”ì„± ë„ì¶œ').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=í˜„ì‹¤ì ì¸ ì£¼ ë‹¨ìœ„ ìŠ¤ì¼€ì¤„ ë° ë¦¬ìŠ¤í¬ ê´€ë¦¬').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=ì„ ì • í™•ë¥ ì„ ë†’ì¼ ì¤€ë¹„ê°€ ë˜ì…¨ë‚˜ìš”?').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=ì§€ê¸ˆ ë°”ë¡œ ì›Œí¬ìˆ ì‹ ì²­í•˜ê¸°').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=â³ ì‹ ì²­ì ‘ìˆ˜ ë§ˆê°: 2026. 1. 5.(ì›”) ê¹Œì§€').first).to_be_visible(timeout=30000)\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/24684438-70f1-70c6-8d9f-d3fa20b9e4b9/1767157157293672//tmp/test_task/result.webm",
    "created": "2025-12-31T04:51:01.628Z",
    "modified": "2025-12-31T04:59:17.517Z"
  },
  {
    "projectId": "53507cae-f23b-4e77-867b-e674622353b3",
    "testId": "f5a5e620-c383-4261-b89b-4e1f22ed11bc",
    "userId": "24684438-70f1-70c6-8d9f-d3fa20b9e4b9",
    "title": "TC006-Overall UI Consistency with Tailwind CSS Styling",
    "description": "Confirm the entire user interface adheres uniformly to Tailwind CSS styling standards providing consistent, intuitive, and visually appealing user experience.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Click on the 'ì»¤ë¦¬í˜ëŸ¼' navigation link to check its page and styling consistency.\n        frame = context.pages[-1]\n        # Click on the 'ì»¤ë¦¬í˜ëŸ¼' navigation link to navigate to the curriculum page and check Tailwind CSS styling consistency.\n        elem = frame.locator('xpath=html/body/nav/div/div[2]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click on the 'AI ë²ˆì—­ ì²´í—˜' navigation link to check its page and styling consistency.\n        frame = context.pages[-1]\n        # Click on the 'AI ë²ˆì—­ ì²´í—˜' navigation link to navigate to the translation demo page and check Tailwind CSS styling consistency.\n        elem = frame.locator('xpath=html/body/nav/div/div[2]/a[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click on the 'ì‹¬ì‚¬ ì „ëµ' navigation link to check its page and styling consistency.\n        frame = context.pages[-1]\n        # Click on the 'ì‹¬ì‚¬ ì „ëµ' navigation link to navigate to the selection strategy page and check Tailwind CSS styling consistency.\n        elem = frame.locator('xpath=html/body/nav/div/div[2]/a[3]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click on the 'ì‹ ì²­í•˜ê¸°' button to open the modal form and verify Tailwind CSS styling consistency in the modal.\n        frame = context.pages[-1]\n        # Click on the 'ì‹ ì²­í•˜ê¸°' button to open the modal form and check Tailwind CSS styling consistency.\n        elem = frame.locator('xpath=html/body/nav/div/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click on each tab button (1ì£¼ì°¨, 2ì£¼ì°¨, 3ì£¼ì°¨, 4ì£¼ì°¨) to verify consistent Tailwind CSS styling and spacing across tab content.\n        frame = context.pages[-1]\n        # Click on the '1ì£¼ì°¨ ì˜¤ë¦¬ì—”í…Œì´ì…˜' tab button to check Tailwind CSS styling consistency in the tab content.\n        elem = frame.locator('xpath=html/body/section[2]/div[2]/div[3]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click on the '2ì£¼ì°¨ ë…¼ë¦¬ êµ¬ì¡°' tab button to verify Tailwind CSS styling consistency in the tab content.\n        frame = context.pages[-1]\n        # Click on the '2ì£¼ì°¨ ë…¼ë¦¬ êµ¬ì¡°' tab button to check Tailwind CSS styling consistency in the tab content.\n        elem = frame.locator('xpath=html/body/section[5]/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click on the '3ì£¼ì°¨ ìƒì„¸ ê¸°íš' tab button to verify Tailwind CSS styling consistency in the tab content.\n        frame = context.pages[-1]\n        # Click on the '3ì£¼ì°¨ ìƒì„¸ ê¸°íš' tab button to check Tailwind CSS styling consistency in the tab content.\n        elem = frame.locator('xpath=html/body/section[2]/div[2]/div[3]/button[3]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click on the '4ì£¼ì°¨ ìµœì¢… ì ê²€' tab button to verify Tailwind CSS styling consistency in the tab content.\n        frame = context.pages[-1]\n        # Click on the '4ì£¼ì°¨ ìµœì¢… ì ê²€' tab button to check Tailwind CSS styling consistency in the tab content.\n        elem = frame.locator('xpath=html/body/div[2]/div/div[2]/form/div/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Scroll down to reveal more form content and verify consistent Tailwind CSS styling and spacing for all form sections.\n        await page.mouse.wheel(0, await page.evaluate('() => window.innerHeight'))\n        \n\n        # -> Perform a responsive design test by resizing the viewport and verifying consistent Tailwind CSS usage and layout across different screen sizes.\n        await page.mouse.wheel(0, -await page.evaluate('() => window.innerHeight'))\n        \n\n        # -> Perform a responsive design test by resizing the viewport and verifying consistent Tailwind CSS usage and layout across different screen sizes.\n        await page.mouse.wheel(0, await page.evaluate('() => window.innerHeight'))\n        \n\n        await page.mouse.wheel(0, -await page.evaluate('() => window.innerHeight'))\n        \n\n        # -> Perform a responsive design test by resizing the viewport and verifying consistent Tailwind CSS usage and layout across different screen sizes.\n        await page.mouse.wheel(0, await page.evaluate('() => window.innerHeight'))\n        \n\n        await page.mouse.wheel(0, -await page.evaluate('() => window.innerHeight'))\n        \n\n        # -> Perform a responsive design test by resizing the viewport and verifying consistent Tailwind CSS usage and layout across different screen sizes.\n        await page.mouse.wheel(0, await page.evaluate('() => window.innerHeight'))\n        \n\n        await page.mouse.wheel(0, -await page.evaluate('() => window.innerHeight'))\n        \n\n        # -> Test interactive states by focusing and hovering over key buttons and input fields to verify consistent Tailwind CSS styling for hover, focus, and active states.\n        frame = context.pages[-1]\n        # Click on the 'ì‹ ì²­ì„œ ì œì¶œí•˜ê¸°' button to check hover and active states visually.\n        elem = frame.locator('xpath=html/body/div[2]/div/div[2]/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        await expect(frame.locator('text=ì»¤ë¦¬í˜ëŸ¼').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=AI ë²ˆì—­ ì²´í—˜').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=ì‹¬ì‚¬ ì „ëµ').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=ì‹ ì²­í•˜ê¸°').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=1ì£¼ì°¨').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=2ì£¼ì°¨').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=3ì£¼ì°¨').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=4ì£¼ì°¨').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=ì˜ˆìˆ ì¸ì„ ìœ„í•œ AI ë§ˆìŠ¤í„° í´ë˜ìŠ¤').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=ì••ë„ì  ë§¥ë½ íŒŒì•…').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=ì‹¤ì‹œê°„ ì •ë³´ ê²€ìƒ‰').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=ì˜ˆìˆ ê°€í˜• í–‰ì • ì–¸ì–´').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=4ì£¼ ì§‘ì¤‘ ì»¤ë¦¬í˜ëŸ¼').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=6ëª… ëª¨ì§‘').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=2026. 1. 7. ~ 1. 28. (ë§¤ì£¼ ìˆ˜) Â |Â  â° 10:00 ~ 12:00').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=íšŒí˜„ë™ ì†Œê·¹ì¥').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=ì‚´ ë¶™ì´ê¸°ì™€ ì‹œê°í™”').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=ìƒì„¸ ì‹¤í–‰ ê³„íš ìˆ˜ë¦½ ë° AIë¥¼ í™œìš©í•œ ì‹œê° ìë£Œ ê¸°íš').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=ê³„íšì„œ ë³¸ë¬¸ 1í˜ì´ì§€ ë° í•µì‹¬ ì‹œê°í™” ìë£Œ 1ì¢…').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=AI ì˜ˆìˆ ê°€ ì–¸ì–´ ë²ˆì—­ê¸°').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=í• ë¨¸ë‹ˆì˜ ì˜›ë‚  ì´ì•¼ê¸°ë¥¼ ê·¸ë¦¼ìœ¼ë¡œ ë‚¨ê¸°ê³  ì‹¶ì–´ìš”.').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=ìš”ì¦˜ ì‚¬ëŒë“¤ì´ ì˜ˆìˆ ì„ ë„ˆë¬´ ëª°ë¼ìš”.').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=ë™ë„¤ ì˜¤ë˜ëœ ì‹œì¥ì´ ì‚¬ë¼ì§€ëŠ” ê²Œ ìŠ¬í¼ìš”.').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=ë‚ ì”¨ ì¢‹ì„ ë•Œ ì•¼ì™¸ì—ì„œ ê³µì—°í•  ìƒê°ì´ì—ìš”.').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=ëª½ê¸€ëª½ê¸€í•˜ê³  ë”°ëœ»í•œ ë¹›ì´ ê°€ë“í•œ ë¬´ëŒ€ë¥¼ ë§Œë“¤ë˜ìš”.').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=ì‹¬ì‚¬ìœ„ì›ì˜').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=ìš°ìˆ˜í•œ ì˜ˆìˆ ì„±(30%)ë„ ì¤‘ìš”í•˜ì§€ë§Œ, í•©ê²©ì˜ ë‹¹ë½ì€ ì‹¤í˜„ê°€ëŠ¥ì„±(30%)ê³¼ ì‚¬ì—…ìˆ˜í–‰ì—­ëŸ‰(20%)ì—ì„œ ê²°ì •ë©ë‹ˆë‹¤. ì›Œí¬ìˆì—ì„œëŠ” AIë¥¼ í™œìš©í•´ ì´ 50%ë¥¼ ì™„ë²½í•˜ê²Œ í™•ë³´í•©ë‹ˆë‹¤.').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=ë°ì´í„° ê¸°ë°˜ì˜ êµ¬ì²´ì ì¸ ì‚¬ì—… í•„ìš”ì„± ë„ì¶œ').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=í˜„ì‹¤ì ì¸ ì£¼ ë‹¨ìœ„ ìŠ¤ì¼€ì¤„ ë° ë¦¬ìŠ¤í¬ ê´€ë¦¬').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=ì„ ì • í™•ë¥ ì„ ë†’ì¼ ì¤€ë¹„ê°€ ë˜ì…¨ë‚˜ìš”?').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=ì§€ê¸ˆ ë°”ë¡œ ì›Œí¬ìˆ ì‹ ì²­í•˜ê¸°').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=â³ ì‹ ì²­ì ‘ìˆ˜ ë§ˆê°: 2026. 1. 5.(ì›”) ê¹Œì§€').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=* ì°¸ì—¬ì í™•ì • ë°œí‘œëŠ” ì„ ì •ëœ ë¶„ë“¤ê»˜ ê°œë³„ ì•ˆë‚´ ë“œë¦½ë‹ˆë‹¤.').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=ğŸ’¡ ì±…ì„ê° ìˆëŠ” ì°¸ì—¬ë¥¼ ìœ„í•´ ë³´ì¦ê¸ˆ 5ë§Œì›ì´ ìˆìŠµë‹ˆë‹¤. (4íšŒ ëª¨ë‘ ì°¸ì„ ì‹œ 100% í™˜ë¶ˆ)').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=[ê°œì¸ì •ë³´ ìˆ˜ì§‘ ë° ì´ìš© ë™ì˜] ìˆ˜ì§‘ëœ ì •ë³´ëŠ” ìš´ì˜ ëª©ì  ì™¸ ì‚¬ìš©ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤.').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=ì‹ ì²­ì„œ ì œì¶œí•˜ê¸°').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Â© 2025 AI Arts Masterclass. All rights reserved.').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Instructor: JENNY').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Built for Artist Max').first).to_be_visible(timeout=30000)\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/24684438-70f1-70c6-8d9f-d3fa20b9e4b9/1767157332393479//tmp/test_task/result.webm",
    "created": "2025-12-31T04:51:01.635Z",
    "modified": "2025-12-31T05:02:12.573Z"
  },
  {
    "projectId": "53507cae-f23b-4e77-867b-e674622353b3",
    "testId": "b45ed0e0-13fe-4124-af43-4539b091f55f",
    "userId": "24684438-70f1-70c6-8d9f-d3fa20b9e4b9",
    "title": "TC007-Modal Accessibility and Keyboard Navigation",
    "description": "Verify that the workshop application modal form supports keyboard accessibility and screen readers for inclusive user experience.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Open the workshop application modal using keyboard navigation (Tab and Enter keys) on the 'ì›Œí¬ìˆ ì‹ ì²­í•˜ê¸°' button.\n        frame = context.pages[-1]\n        # Click the 'ì›Œí¬ìˆ ì‹ ì²­í•˜ê¸°' button to open the workshop application modal.\n        elem = frame.locator('xpath=html/body/header/div/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        await expect(frame.locator('text=ì›Œí¬ìˆ ì‹ ì²­í•˜ê¸°').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=AI í™œìš© ì›Œí¬ìˆ ì‹ ì²­ì„œ').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=ê¸°ë³¸ ì •ë³´ (ì„±í•¨, ì—°ë½ì²˜, ì´ë©”ì¼, í™œë™ ì§€ì—­, ì˜ˆìˆ  ë¶„ì•¼, ì„¸ë¶€ ì˜ˆìˆ í™œë™)').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=AI í™œìš© ê²½í—˜ (ìƒì„±í˜• AI ì‚¬ìš© ê²½í—˜, êµ¬ê¸€ ê³„ì • ì‚¬ìš© ì—¬ë¶€)').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=ê³µëª¨ì‚¬ì—… ë„ì „ ê²½í—˜ (ìµœê·¼ 2ë…„ ë‚´ ê²½í—˜, ëª©í‘œ ê³µëª¨ì‚¬ì—…, ì–´ë ¤ìš´ ì  ì„ íƒ)').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=ì›Œí¬ìˆ ê¸°ëŒ€ ì‚¬í•­ (ì–»ê³  ì‹¶ì€ ê²°ê³¼ë¬¼, AIì—ê²Œ ë¬»ê³  ì‹¶ì€ ì§ˆë¬¸)').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=ì¥ë¹„ ì¤€ë¹„ (ë…¸íŠ¸ë¶/íƒœë¸”ë¦¿ ì§€ì°¸ ê°€ëŠ¥ ì—¬ë¶€)').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=ê°œì¸ì •ë³´ ìˆ˜ì§‘ ë° ì´ìš© ë™ì˜ í•„ìš”, ìš´ì˜ ëª©ì  ì™¸ ì‚¬ìš© ì•ˆ í•¨').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=ì‹ ì²­ì„œ ì œì¶œí•˜ê¸°').first).to_be_visible(timeout=30000)\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/24684438-70f1-70c6-8d9f-d3fa20b9e4b9/1767156886776267//tmp/test_task/result.webm",
    "created": "2025-12-31T04:51:01.643Z",
    "modified": "2025-12-31T04:54:46.907Z"
  },
  {
    "projectId": "53507cae-f23b-4e77-867b-e674622353b3",
    "testId": "eb6491e9-4835-42ae-8360-4591417a5bdc",
    "userId": "24684438-70f1-70c6-8d9f-d3fa20b9e4b9",
    "title": "TC008-Data Collection and Integrity Post Application Submission",
    "description": "Ensure that all user input data from the workshop application modal is collected correctly and submitted data integrity is maintained.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Click the 'ì›Œí¬ìˆ ì‹ ì²­í•˜ê¸°' button to open the workshop application modal form.\n        frame = context.pages[-1]\n        # Click the 'ğŸš€ ì›Œí¬ìˆ ì‹ ì²­í•˜ê¸°' button to open the workshop application modal form.\n        elem = frame.locator('xpath=html/body/header/div/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Fill in the modal form fields with valid, complex inputs including special characters and long text entries.\n        frame = context.pages[-1]\n        # Fill 'ì„±í•¨' field with complex characters\n        elem = frame.locator('xpath=html/body/div[2]/div/div[2]/form/div/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('í™ê¸¸ë™!@# $%^&*()_+|~=`{}[]:\";\\'<>?,./')\n        \n\n        frame = context.pages[-1]\n        # Fill 'ì—°ë½ì²˜' field with valid phone number\n        elem = frame.locator('xpath=html/body/div[2]/div/div[2]/form/div/div/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('010-1234-5678')\n        \n\n        frame = context.pages[-1]\n        # Fill 'ì´ë©”ì¼ (êµ¬ê¸€ê³„ì •)' field with complex email\n        elem = frame.locator('xpath=html/body/div[2]/div/div[2]/form/div/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('complex.email+test@gmail.com')\n        \n\n        frame = context.pages[-1]\n        # Fill 'í™œë™ ì§€ì—­' field with multiple regions and special characters\n        elem = frame.locator('xpath=html/body/div[2]/div/div[2]/form/div/div[3]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('ì„œìš¸ ë§ˆí¬êµ¬ & ê°•ë‚¨êµ¬')\n        \n\n        frame = context.pages[-1]\n        # Fill 'ì˜ˆìˆ  ë¶„ì•¼' field with multiple art fields and special characters\n        elem = frame.locator('xpath=html/body/div[2]/div/div[2]/form/div/div[3]/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('ì‹œê°ì˜ˆìˆ , ì—°ê·¹, ë¬´ìš©, ìŒì•… & í¼í¬ë¨¼ìŠ¤')\n        \n\n        frame = context.pages[-1]\n        # Fill 'ì„¸ë¶€ ì˜ˆìˆ í™œë™' textarea with long text and special characters\n        elem = frame.locator('xpath=html/body/div[2]/div/div[2]/form/div/div[4]/textarea').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('ìµœê·¼ í”„ë¡œì íŠ¸: AIì™€ ì˜ˆìˆ  ìœµí•©! ë‹¤ì–‘í•œ ì‹¤í—˜ê³¼ ì°½ì‘ í™œë™ì„ ì§„í–‰ ì¤‘ì…ë‹ˆë‹¤. íŠ¹ìˆ˜ë¬¸ì í¬í•¨: @#&*()_+{}[]')\n        \n\n        # -> Click the 'ì‹ ì²­ì„œ ì œì¶œí•˜ê¸°' button to submit the workshop application form.\n        frame = context.pages[-1]\n        # Click the 'ì‹ ì²­ì„œ ì œì¶œí•˜ê¸°' button to submit the form.\n        elem = frame.locator('xpath=html/body/div[2]/div/div[2]/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Select a radio button for 'ìƒì„±í˜• AI ì‚¬ìš© ê²½í—˜' to satisfy the required field and resubmit the form.\n        frame = context.pages[-1]\n        # Select 'ì „í˜€ ì—†ë‹¤' option for ìƒì„±í˜• AI ì‚¬ìš© ê²½í—˜ radio button.\n        elem = frame.locator('xpath=html/body/div[2]/div/div[2]/form/div[2]/div/div/label/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click the 'ì‹ ì²­ì„œ ì œì¶œí•˜ê¸°' button to submit the form after all required fields are completed.\n        frame = context.pages[-1]\n        # Click the 'ì‹ ì²­ì„œ ì œì¶œí•˜ê¸°' button to submit the completed workshop application form.\n        elem = frame.locator('xpath=html/body/div[2]/div/div[2]/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Fill in the required 'ìµœê·¼ 2ë…„ ë‚´ ê³µëª¨ì‚¬ì—… ê²½í—˜' textarea and 'ì–»ê³  ì‹¶ì€ ê²°ê³¼ë¬¼' textarea with valid test data, then resubmit the form.\n        frame = context.pages[-1]\n        # Fill 'ìµœê·¼ 2ë…„ ë‚´ ê³µëª¨ì‚¬ì—… ê²½í—˜' textarea with valid test data.\n        elem = frame.locator('xpath=html/body/div[2]/div/div[2]/form/div[3]/div/textarea').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('ìµœê·¼ 2ë…„ ë‚´ ê³µëª¨ì‚¬ì—… ê²½í—˜ì´ ìˆìŠµë‹ˆë‹¤. ì„ ì •ê³¼ ë¹„ì„ ì • ê²½í—˜ ëª¨ë‘ í¬í•¨ë©ë‹ˆë‹¤.')\n        \n\n        frame = context.pages[-1]\n        # Fill 'ì–»ê³  ì‹¶ì€ ê²°ê³¼ë¬¼' textarea with valid test data.\n        elem = frame.locator('xpath=html/body/div[2]/div/div[2]/form/div[4]/div/textarea').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('ì›Œí¬ìˆì„ í†µí•´ AI í™œìš© ëŠ¥ë ¥ì„ í–¥ìƒì‹œí‚¤ê³  ì‹¶ìŠµë‹ˆë‹¤.')\n        \n\n        # -> Click the 'ì‹ ì²­ì„œ ì œì¶œí•˜ê¸°' button to submit the completed workshop application form.\n        frame = context.pages[-1]\n        # Click the 'ì‹ ì²­ì„œ ì œì¶œí•˜ê¸°' button to submit the completed form.\n        elem = frame.locator('xpath=html/body/div[2]/div/div[2]/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Identify and select any remaining required radio buttons or checkboxes that are not yet selected, especially the 'êµ¬ê¸€ ê³„ì • ì‚¬ìš© ì—¬ë¶€' radio buttons, then resubmit the form.\n        frame = context.pages[-1]\n        # Select 'ì•„ë‹ˆì˜¤' option for 'êµ¬ê¸€ ê³„ì • ì‚¬ìš© ì—¬ë¶€' radio button to satisfy required field.\n        elem = frame.locator('xpath=html/body/div[2]/div/div[2]/form/div[2]/div[2]/div/label/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        frame = context.pages[-1]\n        # Click the 'ì‹ ì²­ì„œ ì œì¶œí•˜ê¸°' button to submit the form after all required fields are completed.\n        elem = frame.locator('xpath=html/body/div[2]/div/div[2]/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Select one of the 'ê°œì¸ ë…¸íŠ¸ë¶/íƒœë¸”ë¦¿ ì§€ì°¸ ê°€ëŠ¥ ì—¬ë¶€' radio buttons (index 33 or 35) to satisfy the required field, then resubmit the form.\n        frame = context.pages[-1]\n        # Select 'ì˜ˆ' option for 'ê°œì¸ ë…¸íŠ¸ë¶/íƒœë¸”ë¦¿ ì§€ì°¸ ê°€ëŠ¥ ì—¬ë¶€' radio button.\n        elem = frame.locator('xpath=html/body/div[2]/div/div[2]/form/div[5]/div/div/label/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click the 'ì‹ ì²­ì„œ ì œì¶œí•˜ê¸°' button to submit the completed workshop application form and verify data integrity.\n        frame = context.pages[-1]\n        # Click the 'ì‹ ì²­ì„œ ì œì¶œí•˜ê¸°' button to submit the completed form.\n        elem = frame.locator('xpath=html/body/div[2]/div/div[2]/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Verify that the data received on the backend or simulated backend matches exactly the user input, checking for any data loss, truncation, or corruption, and confirm all fields are accurately captured and stored.\n        await page.goto('http://localhost:3000/dashboard', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # -> Return to the main page or another accessible page to check for submission status or alternative verification methods.\n        await page.goto('http://localhost:3000', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # -> Click the 'ì›Œí¬ìˆ ì‹ ì²­í•˜ê¸°' button to reopen the workshop application modal and check for any submission status or confirmation messages.\n        frame = context.pages[-1]\n        # Click the 'ğŸš€ ì›Œí¬ìˆ ì‹ ì²­í•˜ê¸°' button to open the workshop application modal.\n        elem = frame.locator('xpath=html/body/header/div/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=ë°ì´í„° ë¬´ê²°ì„± í™•ì¸ ì™„ë£Œ').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: The workshop application data integrity check did not pass. The expected confirmation text 'ë°ì´í„° ë¬´ê²°ì„± í™•ì¸ ì™„ë£Œ' was not found, indicating possible data loss, truncation, or corruption during submission.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "The workshop application modal form was successfully filled with complex inputs including special characters and long text entries. All required fields including text inputs, radio buttons, and checkboxes were selected. The form was submitted successfully as indicated by the submission process starting. However, attempts to verify the submitted data on the backend via the dashboard failed due to a 404 error page. Returning to the main page and reopening the modal did not reveal any submission confirmation or status. Therefore, full verification of data integrity on the backend could not be completed. The task is partially complete with successful form submission but incomplete backend data verification.\nBrowser Console Logs:\n[WARNING] cdn.tailwindcss.com should not be used in production. To use Tailwind CSS in production, install it as a PostCSS plugin or use the Tailwind CLI: https://tailwindcss.com/docs/installation (at https://cdn.tailwindcss.com/:63:1710)\n[ERROR] Failed to load resource: the server responded with a status of 404 (Not Found) (at http://localhost:3000/dashboard:0:0)\n[WARNING] cdn.tailwindcss.com should not be used in production. To use Tailwind CSS in production, install it as a PostCSS plugin or use the Tailwind CLI: https://tailwindcss.com/docs/installation (at https://cdn.tailwindcss.com/:63:1710)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/24684438-70f1-70c6-8d9f-d3fa20b9e4b9/1767157337918751//tmp/test_task/result.webm",
    "created": "2025-12-31T04:51:01.649Z",
    "modified": "2025-12-31T05:02:18.113Z"
  },
  {
    "projectId": "53507cae-f23b-4e77-867b-e674622353b3",
    "testId": "8b2a000d-13b9-4c13-967b-3c2b9fdd3176",
    "userId": "24684438-70f1-70c6-8d9f-d3fa20b9e4b9",
    "title": "TC009-Error Handling for Network or Submission Failures",
    "description": "Verify the system behavior when form submission fails due to network issues or server errors, ensuring informative feedback is provided to the user.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Click the 'ì‹ ì²­í•˜ê¸°' (Apply) button to open the application form modal.\n        frame = context.pages[-1]\n        # Click the 'ì‹ ì²­í•˜ê¸°' button to open the application form modal.\n        elem = frame.locator('xpath=html/body/nav/div/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Simulate network failure or backend service unavailability during form submission and then submit the form.\n        frame = context.pages[-1]\n        # Click the 'ì‹ ì²­ì„œ ì œì¶œí•˜ê¸°' button to submit the application form and simulate network failure.\n        elem = frame.locator('xpath=html/body/div[2]/div/div[2]/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Fill the form with valid data and simulate network failure or backend service unavailability during form submission, then submit the form.\n        frame = context.pages[-1]\n        # Fill in the name field with valid data\n        elem = frame.locator('xpath=html/body/div[2]/div/div[2]/form/div/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('í™ê¸¸ë™')\n        \n\n        frame = context.pages[-1]\n        # Fill in the phone number field with valid data\n        elem = frame.locator('xpath=html/body/div[2]/div/div[2]/form/div/div/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('010-1234-5678')\n        \n\n        frame = context.pages[-1]\n        # Fill in the email field with valid data\n        elem = frame.locator('xpath=html/body/div[2]/div/div[2]/form/div/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('test@example.com')\n        \n\n        frame = context.pages[-1]\n        # Fill in the activity region field with valid data\n        elem = frame.locator('xpath=html/body/div[2]/div/div[2]/form/div/div[3]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('ì„œìš¸ ë§ˆí¬êµ¬')\n        \n\n        frame = context.pages[-1]\n        # Fill in the art field with valid data\n        elem = frame.locator('xpath=html/body/div[2]/div/div[2]/form/div/div[3]/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('ì‹œê°ì˜ˆìˆ ')\n        \n\n        frame = context.pages[-1]\n        # Fill in the detailed art activity field with valid data\n        elem = frame.locator('xpath=html/body/div[2]/div/div[2]/form/div/div[4]/textarea').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('ìµœê·¼ í”„ë¡œì íŠ¸ë‚˜ í™œë™ ë‚´ìš©ì„ ê°„ë‹¨íˆ ì ì–´ì£¼ì„¸ìš”.')\n        \n\n        frame = context.pages[-1]\n        # Select 'ì „í˜€ ì—†ë‹¤' for AI usage experience\n        elem = frame.locator('xpath=html/body/div[2]/div/div[2]/form/div[2]/div/div/label/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        frame = context.pages[-1]\n        # Select 'ì˜ˆ' for Google account usage\n        elem = frame.locator('xpath=html/body/div[2]/div/div[2]/form/div[2]/div[2]/div/label').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        frame = context.pages[-1]\n        # Fill in the target grant field with valid data\n        elem = frame.locator('xpath=html/body/div[2]/div/div[2]/form/div[3]/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('ë¬¸í™”ì˜ˆìˆ  ê³µëª¨ì‚¬ì—…')\n        \n\n        frame = context.pages[-1]\n        # Select 'ì‚¬ì—… ëª©ì  ë° ë…¼ë¦¬ ê°œë°œ' as difficulty\n        elem = frame.locator('xpath=html/body/div[2]/div/div[2]/form/div[3]/div[3]/div/label[3]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Simulate network failure or backend service unavailability during form submission and then submit the form.\n        frame = context.pages[-1]\n        # Click the 'ì‹ ì²­ì„œ ì œì¶œí•˜ê¸°' button to submit the form and trigger network failure simulation.\n        elem = frame.locator('xpath=html/body/div[2]/div/div[2]/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Fill the missing required fields 'ì–»ê³  ì‹¶ì€ ê²°ê³¼ë¬¼' and check the 'ë™ì˜í•©ë‹ˆë‹¤' checkbox, then simulate network failure during form submission.\n        frame = context.pages[-1]\n        # Fill in the 'ì–»ê³  ì‹¶ì€ ê²°ê³¼ë¬¼' field with valid data\n        elem = frame.locator('xpath=html/body/div[2]/div/div[2]/form/div[4]/div/textarea').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('ì›Œí¬ìˆì„ í†µí•´ AI í™œìš© ëŠ¥ë ¥ì„ í–¥ìƒì‹œí‚¤ê³  ì‹¶ìŠµë‹ˆë‹¤.')\n        \n\n        frame = context.pages[-1]\n        # Check the 'ë™ì˜í•©ë‹ˆë‹¤' checkbox to agree to ê°œì¸ì •ë³´ ìˆ˜ì§‘ ë° ì´ìš© ë™ì˜\n        elem = frame.locator('xpath=html/body/div[2]/div/div[2]/form/div[7]/label/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        frame = context.pages[-1]\n        # Click the 'ì‹ ì²­ì„œ ì œì¶œí•˜ê¸°' button to submit the form and simulate network failure.\n        elem = frame.locator('xpath=html/body/div[2]/div/div[2]/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Select the 'ì˜ˆ' option for 'ê°œì¸ ë…¸íŠ¸ë¶/íƒœë¸”ë¦¿ ì§€ì°¸ ê°€ëŠ¥ ì—¬ë¶€' and then simulate network failure during form submission by submitting the form.\n        frame = context.pages[-1]\n        # Select 'ì˜ˆ' for ê°œì¸ ë…¸íŠ¸ë¶/íƒœë¸”ë¦¿ ì§€ì°¸ ê°€ëŠ¥ ì—¬ë¶€ to satisfy required field.\n        elem = frame.locator('xpath=html/body/div[2]/div/div[2]/form/div[5]/div/div/label/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Submission Successful! Your application has been received.').first).to_be_visible(timeout=3000)\n        except AssertionError:\n            raise AssertionError(\"Test failed: The form submission did not succeed due to network or server errors as expected. The system should display a clear, user-friendly error message and keep the form open for retry.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Testing stopped due to a form bug where the 'ê°œì¸ ë…¸íŠ¸ë¶/íƒœë¸”ë¦¿ ì§€ì°¸ ê°€ëŠ¥ ì—¬ë¶€' radio button selection does not register, preventing form submission and network failure simulation. Issue reported for developer fix.\nBrowser Console Logs:\n[WARNING] cdn.tailwindcss.com should not be used in production. To use Tailwind CSS in production, install it as a PostCSS plugin or use the Tailwind CLI: https://tailwindcss.com/docs/installation (at https://cdn.tailwindcss.com/:63:1710)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/24684438-70f1-70c6-8d9f-d3fa20b9e4b9/1767157146773498//tmp/test_task/result.webm",
    "created": "2025-12-31T04:51:01.656Z",
    "modified": "2025-12-31T04:59:06.938Z"
  }
]
